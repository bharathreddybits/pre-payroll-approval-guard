{
  "name": "PPG - Process Review",
  "nodes": [
    {
      "parameters": {
        "path": "ppg-process-review",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "webhookId": "a1b2c3d4-0001-4000-8000-000000000099"
    },
    {
      "parameters": {
        "jsCode": "// ==========================================================================\n// Code Node 1: Validate & Fetch Data\n// Auto-generated by scripts/generate-n8n-workflow.js\n// ==========================================================================\n\n// fetch polyfill for n8n Code node sandbox\nconst https = require('https');\nconst http = require('http');\n\n// Parse URL manually since URL class is not available in sandbox\nfunction parseUrl(urlStr) {\n  const match = urlStr.match(/^(https?):\\/\\/([^:/]+)(?::(\\d+))?(\\/.*)?$/);\n  if (!match) throw new Error('Invalid URL: ' + urlStr);\n  return {\n    protocol: match[1],\n    hostname: match[2],\n    port: match[3] ? parseInt(match[3]) : (match[1] === 'https' ? 443 : 80),\n    path: match[4] || '/'\n  };\n}\n\nfunction fetch(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const u = parseUrl(url);\n    const mod = u.protocol === 'https' ? https : http;\n    const req = mod.request({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      method: options.method || 'GET',\n      headers: options.headers || {},\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        resolve({\n          ok: res.statusCode >= 200 && res.statusCode < 300,\n          status: res.statusCode,\n          statusText: res.statusMessage || '',\n          json: () => JSON.parse(data),\n          text: () => data,\n        });\n      });\n    });\n    req.on('error', reject);\n    if (options.body) req.write(options.body);\n    req.end();\n  });\n}\n\nconst SUPABASE_URL = $env.SUPABASE_URL;\nconst SUPABASE_KEY = $env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!SUPABASE_URL || !SUPABASE_KEY) {\n  throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY env vars');\n}\n\nconst webhookData = $input.first().json;\n// n8n webhook nests POST body under .body\nconst body = webhookData.body || webhookData;\nconst reviewSessionId = body.review_session_id;\n\nif (!reviewSessionId) {\n  throw new Error('Missing review_session_id in request body');\n}\n\nconst headers = {\n  'apikey': SUPABASE_KEY,\n  'Authorization': 'Bearer ' + SUPABASE_KEY,\n  'Content-Type': 'application/json',\n  'Prefer': 'return=representation',\n};\n\n// Update session status to processing\nawait fetch(\n  SUPABASE_URL + '/rest/v1/review_session?review_session_id=eq.' + reviewSessionId,\n  {\n    method: 'PATCH',\n    headers,\n    body: JSON.stringify({ status: 'processing' }),\n  }\n);\n\n// Fetch datasets\nconst dsRes = await fetch(\n  SUPABASE_URL + '/rest/v1/payroll_dataset?review_session_id=eq.' + reviewSessionId + '&select=*',\n  { headers }\n);\nif (!dsRes.ok) throw new Error('Failed to fetch datasets: ' + dsRes.statusText);\nconst datasets = await dsRes.json();\n\nif (!Array.isArray(datasets) || datasets.length !== 2) {\n  throw new Error('Expected 2 datasets, found ' + (datasets ? datasets.length : 0));\n}\n\nconst baseline = datasets.find(d => d.dataset_type === 'baseline');\nconst current = datasets.find(d => d.dataset_type === 'current');\nif (!baseline || !current) throw new Error('Missing baseline or current dataset');\n\nconst orgId = baseline.organization_id;\n\n// Fetch org tier\nconst tierRes = await fetch(\n  SUPABASE_URL + '/rest/v1/organization_tier?organization_id=eq.' + orgId + '&select=tier',\n  { headers }\n);\nconst tierData = tierRes.ok ? await tierRes.json() : [];\nconst orgTier = (tierData && tierData[0] && tierData[0].tier === 'pro') ? 'pro' : 'starter';\n\n// Fetch baseline employees\nconst blEmpRes = await fetch(\n  SUPABASE_URL + '/rest/v1/employee_pay_record?dataset_id=eq.' + baseline.dataset_id + '&select=*&limit=10000',\n  { headers }\n);\nif (!blEmpRes.ok) throw new Error('Failed to fetch baseline employees: ' + blEmpRes.statusText);\nconst baselineEmployees = await blEmpRes.json();\n\n// Fetch current employees\nconst curEmpRes = await fetch(\n  SUPABASE_URL + '/rest/v1/employee_pay_record?dataset_id=eq.' + current.dataset_id + '&select=*&limit=10000',\n  { headers }\n);\nif (!curEmpRes.ok) throw new Error('Failed to fetch current employees: ' + curEmpRes.statusText);\nconst currentEmployees = await curEmpRes.json();\n\nif (!baselineEmployees || baselineEmployees.length === 0) throw new Error('No baseline employees');\nif (!currentEmployees || currentEmployees.length === 0) throw new Error('No current employees');\n\n// Attach empty pay_components for rule compatibility\nfor (const emp of [...baselineEmployees, ...currentEmployees]) {\n  emp.pay_components = [];\n}\n\nreturn [{\n  json: {\n    reviewSessionId,\n    orgId,\n    orgTier,\n    baselineEmployees,\n    currentEmployees,\n  }\n}];",
        "mode": "runOnceForAllItems"
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000002",
      "name": "Fetch Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        300,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ==========================================================================\n// Code Node 2: Calculate & Insert Deltas\n// Auto-generated by scripts/generate-n8n-workflow.js\n// ==========================================================================\n\n// fetch polyfill for n8n Code node sandbox\nconst https = require('https');\nconst http = require('http');\n\n// Parse URL manually since URL class is not available in sandbox\nfunction parseUrl(urlStr) {\n  const match = urlStr.match(/^(https?):\\/\\/([^:/]+)(?::(\\d+))?(\\/.*)?$/);\n  if (!match) throw new Error('Invalid URL: ' + urlStr);\n  return {\n    protocol: match[1],\n    hostname: match[2],\n    port: match[3] ? parseInt(match[3]) : (match[1] === 'https' ? 443 : 80),\n    path: match[4] || '/'\n  };\n}\n\nfunction fetch(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const u = parseUrl(url);\n    const mod = u.protocol === 'https' ? https : http;\n    const req = mod.request({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      method: options.method || 'GET',\n      headers: options.headers || {},\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        resolve({\n          ok: res.statusCode >= 200 && res.statusCode < 300,\n          status: res.statusCode,\n          statusText: res.statusMessage || '',\n          json: () => JSON.parse(data),\n          text: () => data,\n        });\n      });\n    });\n    req.on('error', reject);\n    if (options.body) req.write(options.body);\n    req.end();\n  });\n}\n\nconst SUPABASE_URL = $env.SUPABASE_URL;\nconst SUPABASE_KEY = $env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst input = $input.first().json;\nconst { reviewSessionId, orgId, orgTier, baselineEmployees, currentEmployees } = input;\n\nconst headers = {\n  'apikey': SUPABASE_KEY,\n  'Authorization': 'Bearer ' + SUPABASE_KEY,\n  'Content-Type': 'application/json',\n  'Prefer': 'return=representation',\n};\n\nconst DELTA_METRICS = [\"regular_hours\",\"overtime_hours\",\"other_paid_hours\",\"total_hours_worked\",\"base_earnings\",\"overtime_pay\",\"bonus_earnings\",\"other_earnings\",\"federal_income_tax\",\"social_security_tax\",\"medicare_tax\",\"state_income_tax\",\"local_tax\",\"total_deductions\",\"gross_pay\",\"net_pay\"];\nconst BASE_METRICS = ['net_pay', 'gross_pay', 'total_deductions'];\n\nfunction getFieldValue(emp, field) {\n  if (emp[field] != null) {\n    const val = Number(emp[field]);\n    return isNaN(val) ? null : val;\n  }\n  if (emp.metadata && emp.metadata[field] != null) {\n    const val = Number(emp.metadata[field]);\n    return isNaN(val) ? null : val;\n  }\n  return null;\n}\n\n// Build lookup maps\nconst baselineMap = new Map(baselineEmployees.map(e => [e.employee_id, e]));\nconst currentMap = new Map(currentEmployees.map(e => [e.employee_id, e]));\n\nconst deltas = [];\n\n// Removed employees\nfor (const [employeeId, baselineEmp] of baselineMap) {\n  if (!currentMap.has(employeeId)) {\n    deltas.push({\n      review_session_id: reviewSessionId,\n      organization_id: orgId,\n      employee_id: employeeId,\n      metric: 'net_pay',\n      change_type: 'removed_employee',\n      baseline_value: getFieldValue(baselineEmp, 'net_pay'),\n      current_value: null,\n      delta_absolute: null,\n      delta_percentage: null,\n    });\n  }\n}\n\n// New employees and metric-level changes\nfor (const [employeeId, currentEmp] of currentMap) {\n  const baselineEmp = baselineMap.get(employeeId);\n\n  if (!baselineEmp) {\n    deltas.push({\n      review_session_id: reviewSessionId,\n      organization_id: orgId,\n      employee_id: employeeId,\n      metric: 'net_pay',\n      change_type: 'new_employee',\n      baseline_value: null,\n      current_value: getFieldValue(currentEmp, 'net_pay'),\n      delta_absolute: null,\n      delta_percentage: null,\n    });\n  } else {\n    let hasAnyDelta = false;\n\n    for (const metric of DELTA_METRICS) {\n      const bVal = getFieldValue(baselineEmp, metric);\n      const cVal = getFieldValue(currentEmp, metric);\n      if (bVal == null && cVal == null) continue;\n\n      const bNum = bVal ?? 0;\n      const cNum = cVal ?? 0;\n\n      if (bNum !== cNum) {\n        const deltaAbs = cNum - bNum;\n        let deltaPct = bNum !== 0 ? (deltaAbs / Math.abs(bNum)) * 100 : null;\n        if (deltaPct !== null) {\n          deltaPct = Math.max(-999.99, Math.min(999.99, Math.round(deltaPct * 100) / 100));\n        }\n\n        deltas.push({\n          review_session_id: reviewSessionId,\n          organization_id: orgId,\n          employee_id: employeeId,\n          metric,\n          change_type: deltaAbs > 0 ? 'increase' : 'decrease',\n          baseline_value: bNum,\n          current_value: cNum,\n          delta_absolute: deltaAbs,\n          delta_percentage: deltaPct,\n        });\n        hasAnyDelta = true;\n      }\n    }\n\n    if (!hasAnyDelta) {\n      deltas.push({\n        review_session_id: reviewSessionId,\n        organization_id: orgId,\n        employee_id: employeeId,\n        metric: 'net_pay',\n        change_type: 'no_change',\n        baseline_value: getFieldValue(baselineEmp, 'net_pay') ?? 0,\n        current_value: getFieldValue(currentEmp, 'net_pay') ?? 0,\n        delta_absolute: 0,\n        delta_percentage: 0,\n      });\n    }\n  }\n}\n\nif (deltas.length === 0) {\n  return [{ json: { reviewSessionId, orgId, orgTier, insertedDeltas: [], currentEmployees, baselineEmployees, deltaCount: 0, message: 'No deltas' } }];\n}\n\n// Insert deltas in batches\nconst BATCH_SIZE = 200;\nconst insertedDeltas = [];\nlet deltasToInsert = deltas;\n\n// Try first batch; if expanded metrics fail, fall back to base metrics\nconst firstBatch = deltasToInsert.slice(0, Math.min(BATCH_SIZE, deltasToInsert.length));\nconst testRes = await fetch(SUPABASE_URL + '/rest/v1/payroll_delta', {\n  method: 'POST',\n  headers,\n  body: JSON.stringify(firstBatch),\n});\n\nif (!testRes.ok) {\n  deltasToInsert = deltas.filter(d =>\n    BASE_METRICS.includes(d.metric) ||\n    d.change_type === 'new_employee' ||\n    d.change_type === 'removed_employee'\n  );\n  for (let i = 0; i < deltasToInsert.length; i += BATCH_SIZE) {\n    const batch = deltasToInsert.slice(i, i + BATCH_SIZE);\n    const res = await fetch(SUPABASE_URL + '/rest/v1/payroll_delta', {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n    if (!res.ok) throw new Error('Failed to insert deltas: ' + await res.text());\n    const data = await res.json();\n    insertedDeltas.push(...data);\n  }\n} else {\n  const testData = await testRes.json();\n  insertedDeltas.push(...testData);\n  for (let i = BATCH_SIZE; i < deltasToInsert.length; i += BATCH_SIZE) {\n    const batch = deltasToInsert.slice(i, i + BATCH_SIZE);\n    const res = await fetch(SUPABASE_URL + '/rest/v1/payroll_delta', {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n    if (!res.ok) throw new Error('Failed to insert deltas: ' + await res.text());\n    const data = await res.json();\n    insertedDeltas.push(...data);\n  }\n}\n\nreturn [{\n  json: {\n    reviewSessionId,\n    orgId,\n    orgTier,\n    insertedDeltas,\n    currentEmployees,\n    baselineEmployees,\n    deltaCount: insertedDeltas.length,\n  }\n}];",
        "mode": "runOnceForAllItems"
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000003",
      "name": "Calculate Deltas",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ==========================================================================\n// Code Node 3: Apply Rules & Insert Judgements\n// Auto-generated by scripts/generate-n8n-workflow.js\n// Contains all 54 rules from lib/rules/\n// ==========================================================================\n\n// fetch polyfill for n8n Code node sandbox\nconst https = require('https');\nconst http = require('http');\n\n// Parse URL manually since URL class is not available in sandbox\nfunction parseUrl(urlStr) {\n  const match = urlStr.match(/^(https?):\\/\\/([^:/]+)(?::(\\d+))?(\\/.*)?$/);\n  if (!match) throw new Error('Invalid URL: ' + urlStr);\n  return {\n    protocol: match[1],\n    hostname: match[2],\n    port: match[3] ? parseInt(match[3]) : (match[1] === 'https' ? 443 : 80),\n    path: match[4] || '/'\n  };\n}\n\nfunction fetch(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const u = parseUrl(url);\n    const mod = u.protocol === 'https' ? https : http;\n    const req = mod.request({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      method: options.method || 'GET',\n      headers: options.headers || {},\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        resolve({\n          ok: res.statusCode >= 200 && res.statusCode < 300,\n          status: res.statusCode,\n          statusText: res.statusMessage || '',\n          json: () => JSON.parse(data),\n          text: () => data,\n        });\n      });\n    });\n    req.on('error', reject);\n    if (options.body) req.write(options.body);\n    req.end();\n  });\n}\n\nconst SUPABASE_URL = $env.SUPABASE_URL;\nconst SUPABASE_KEY = $env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst input = $input.first().json;\nconst { reviewSessionId, orgId, orgTier, insertedDeltas, currentEmployees, baselineEmployees } = input;\n\nconst headers = {\n  'apikey': SUPABASE_KEY,\n  'Authorization': 'Bearer ' + SUPABASE_KEY,\n  'Content-Type': 'application/json',\n};\n\n// ===== Rules (auto-generated from lib/rules/*.ts) =====\n\nconst employeeIdentityRules = [\n  {\n    id: 'INACTIVE_EMPLOYEE_PAID',\n    name: 'Inactive employee paid',\n    category: 'Employee Identity & Context',\n    severity: 'blocker',\n    confidence: 0.98,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const status = ctx.current.employment_status;\n      const gross = ctx.current.gross_pay;\n      return status != null && status.toLowerCase() !== 'active' && gross != null && gross > 0;\n    },\n    explanation: 'Inactive employee received pay',\n    userAction: 'Fix status or reverse payment',\n    columnsUsed: ['EmployeeID', 'Employment_Status', 'GrossPay'],\n    minTier: 'pro',\n    flagReason: 'An employee marked as inactive, terminated, or on leave is receiving pay in the current run.',\n    riskStatement: 'Paying inactive employees results in overpayments, tax filing errors, and potential compliance violations.',\n    commonCauses: [\n      'Termination not processed before payroll cutoff',\n      'Status field not updated in HRIS',\n      'Leave-of-absence employee incorrectly included',\n      'Rehire processed but status not changed back to active',\n    ],\n    reviewSteps: [\n      'Verify employee status in your HRIS system',\n      'Check if termination was processed before payroll cutoff',\n      'Confirm whether this is a valid final paycheck',\n      'If overpayment, initiate reversal process',\n    ],\n  },\n  {\n    id: 'MISSING_EMPLOYEE_ID',\n    name: 'Missing employee ID',\n    category: 'Employee Identity & Context',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const empId = ctx.current.employee_id;\n      return empId == null || String(empId).trim() === '';\n    },\n    explanation: 'Employee cannot be uniquely identified',\n    userAction: 'Populate EmployeeID',\n    columnsUsed: ['EmployeeID'],\n    minTier: 'starter',\n    flagReason: 'A payroll record exists without an employee identifier.',\n    riskStatement: 'Records without employee IDs cannot be matched, audited, or reported. This blocks all downstream processing.',\n    commonCauses: [\n      'CSV export missing the employee ID column',\n      'New hire not yet assigned an employee number',\n      'Data formatting issue stripped the ID field',\n      'Manual entry with blank identifier',\n    ],\n    reviewSteps: [\n      'Check the source CSV for missing or blank employee ID values',\n      'Verify all employees have IDs assigned in your payroll system',\n      'Re-export the file with the employee ID column populated',\n      'Upload the corrected file',\n    ],\n  },\n  {\n    id: 'EMPLOYMENT_STATUS_CHANGE',\n    name: 'Employment status changed',\n    category: 'Employee Identity & Context',\n    severity: 'review',\n    confidence: 0.95,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bStatus = ctx.baseline.employment_status;\n      const cStatus = ctx.current.employment_status;\n      return bStatus != null && cStatus != null && bStatus !== cStatus;\n    },\n    explanation: 'Employment status changed from baseline (e.g., Active to Terminated).',\n    userAction: 'Verify status update in HR records; confirm termination paperwork if applicable.',\n    columnsUsed: ['Employment_Status'],\n    minTier: 'pro',\n    flagReason: 'Employment status changed between the previous and current payroll run.',\n    riskStatement: 'Status changes affect benefit eligibility, tax withholding, and final pay calculations.',\n    commonCauses: [\n      'Employee termination or resignation',\n      'Transition from full-time to part-time',\n      'Leave of absence initiated or ended',\n      'Data entry error in HRIS',\n    ],\n    reviewSteps: [\n      'Confirm the status change matches HR records',\n      'Verify final pay calculations for terminated employees',\n      'Check benefit and deduction adjustments',\n      'Ensure proper tax treatment for the new status',\n    ],\n  },\n  {\n    id: 'DUPLICATE_EMPLOYEE_ROWS',\n    name: 'Duplicate employee rows',\n    category: 'Employee Identity & Context',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      if (!ctx.allCurrentEmployees) return false;\n      const empId = ctx.current.employee_id;\n      const count = ctx.allCurrentEmployees.filter(e => e.employee_id === empId).length;\n      return count > 1;\n    },\n    explanation: 'Duplicate employee records found',\n    userAction: 'De-duplicate rows',\n    columnsUsed: ['EmployeeID'],\n    minTier: 'starter',\n    flagReason: 'The same employee ID appears more than once in the current payroll file.',\n    riskStatement: 'Duplicate rows cause double payments, incorrect tax withholding totals, and reporting errors.',\n    commonCauses: [\n      'Employee listed under multiple pay groups',\n      'CSV export included duplicate rows',\n      'Supplemental run merged with regular run',\n      'Manual data entry created a duplicate',\n    ],\n    reviewSteps: [\n      'Search for the duplicated employee ID in the source file',\n      'Determine which row is correct and remove the duplicate',\n      'If both rows are valid, consolidate into one record',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'PAY_FREQUENCY_CHANGED',\n    name: 'Pay frequency changed',\n    category: 'Employee Identity & Context',\n    severity: 'review',\n    confidence: 0.9,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bFreq = ctx.baseline.pay_frequency;\n      const cFreq = ctx.current.pay_frequency;\n      return bFreq != null && cFreq != null && bFreq !== cFreq;\n    },\n    explanation: 'Confirm payroll setup change; check for proration impacts.',\n    userAction: 'Verify pay frequency change and proration',\n    columnsUsed: ['Pay_Frequency'],\n    minTier: 'pro',\n    flagReason: 'Pay frequency changed between payroll runs (e.g., bi-weekly to semi-monthly).',\n    riskStatement: 'Pay frequency changes affect salary proration, benefit deduction timing, and tax withholding calculations.',\n    commonCauses: [\n      'Company-wide payroll calendar change',\n      'Employee transferred to a different pay schedule',\n      'Data entry error in pay frequency field',\n      'Payroll system migration artifact',\n    ],\n    reviewSteps: [\n      'Confirm the frequency change is authorized',\n      'Verify salary proration is correct for the new frequency',\n      'Check that deduction amounts reflect the new schedule',\n      'Validate tax withholding adjustments',\n    ],\n  },\n  {\n    id: 'MISSING_PAY_FREQUENCY',\n    name: 'Missing pay frequency',\n    category: 'Employee Identity & Context',\n    severity: 'review',\n    confidence: 0.9,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const freq = ctx.current.pay_frequency;\n      return freq == null || String(freq).trim() === '';\n    },\n    explanation: 'Pay frequency missing',\n    userAction: 'Assign pay frequency',\n    columnsUsed: ['Pay_Frequency'],\n    minTier: 'pro',\n    flagReason: 'Pay frequency is not set for this employee.',\n    riskStatement: 'Missing pay frequency prevents accurate proration, deduction timing, and annual tax calculations.',\n    commonCauses: [\n      'Field not included in the CSV export',\n      'New hire setup incomplete',\n      'Payroll system migration did not map frequency',\n    ],\n    reviewSteps: [\n      'Add the pay frequency to the employee record',\n      'Verify the correct frequency (weekly, bi-weekly, semi-monthly, monthly)',\n      'Re-export with the field populated',\n    ],\n  },\n  {\n    id: 'PAY_GROUP_CHANGED',\n    name: 'Pay group changed unexpectedly',\n    category: 'Employee Identity & Context',\n    severity: 'review',\n    confidence: 0.88,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bGroup = ctx.baseline.pay_group;\n      const cGroup = ctx.current.pay_group;\n      return bGroup != null && cGroup != null && bGroup !== cGroup;\n    },\n    explanation: 'Pay group changed from prior run',\n    userAction: 'Confirm reassignment',\n    columnsUsed: ['Pay_Group'],\n    minTier: 'pro',\n    flagReason: 'Employee pay group changed between payroll runs.',\n    riskStatement: 'Pay group changes can affect payment timing, bank routing, and benefit eligibility.',\n    commonCauses: [\n      'Employee transferred to a different department or location',\n      'Organizational restructuring',\n      'Data entry error',\n    ],\n    reviewSteps: [\n      'Confirm the pay group reassignment is intentional',\n      'Verify payment routing and timing are correct',\n      'Check for downstream impacts on benefits or reporting',\n    ],\n  },\n  {\n    id: 'PAY_PERIOD_START_AFTER_END',\n    name: 'Pay period start after end date',\n    category: 'Employee Identity & Context',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const start = ctx.current.metadata?.pay_period_start;\n      const end = ctx.current.metadata?.pay_period_end;\n      if (!start || !end) return false;\n      return new Date(start) > new Date(end);\n    },\n    explanation: 'Pay period start after end date.',\n    userAction: 'Correct dates in source file and re-upload.',\n    columnsUsed: ['PayPeriodStart', 'PayPeriodEnd'],\n    minTier: 'pro',\n    flagReason: 'The pay period start date is after the end date, which is logically impossible.',\n    riskStatement: 'Invalid pay period dates cause incorrect proration, tax calculations, and regulatory reporting.',\n    commonCauses: [\n      'Start and end dates swapped in the CSV',\n      'Date format mismatch (MM/DD vs DD/MM)',\n      'Copy-paste error from previous period',\n    ],\n    reviewSteps: [\n      'Review the pay period dates in your source file',\n      'Correct the date order or format',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'PAY_PERIOD_MISMATCH',\n    name: 'Pay period mismatch',\n    category: 'Employee Identity & Context',\n    severity: 'blocker',\n    confidence: 0.95,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      return false;\n    },\n    explanation: 'Pay period dates inconsistent across employees',\n    userAction: 'Fix period setup',\n    columnsUsed: ['PayPeriodStart', 'PayPeriodEnd'],\n    minTier: 'pro',\n    flagReason: 'Different employees in the same payroll run have different pay period dates.',\n    riskStatement: 'Mismatched pay periods indicate mixed payroll runs or data corruption.',\n    commonCauses: [\n      'Multiple pay periods accidentally merged into one file',\n      'Off-cycle or supplemental run mixed with regular run',\n      'Manual date entry errors',\n    ],\n    reviewSteps: [\n      'Check if all employees should have the same pay period',\n      'Separate different pay periods into distinct files if needed',\n      'Correct any date errors and re-upload',\n    ],\n  },\n  {\n    id: 'PAY_DATE_IN_PAST',\n    name: 'Pay date in past',\n    category: 'Employee Identity & Context',\n    severity: 'review',\n    confidence: 0.85,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const payDate = ctx.current.metadata?.pay_date;\n      const periodEnd = ctx.current.metadata?.pay_period_end;\n      if (!payDate || !periodEnd) return false;\n      return new Date(payDate) < new Date(periodEnd);\n    },\n    explanation: 'Pay date earlier than period end',\n    userAction: 'Confirm payroll calendar',\n    columnsUsed: ['PayDate', 'PayPeriodEnd'],\n    minTier: 'pro',\n    flagReason: 'The pay date is before the pay period end date.',\n    riskStatement: 'Early pay dates may indicate calendar errors affecting tax deposit timing.',\n    commonCauses: [\n      'Payroll calendar not updated for the new period',\n      'Holiday-adjusted pay date not reflected',\n      'Date field contains wrong value',\n    ],\n    reviewSteps: [\n      'Verify the pay date against your payroll calendar',\n      'Confirm if this is an intentional early payment',\n      'Correct the date if it is an error',\n    ],\n  },\n  {\n    id: 'DEPARTMENT_MISSING',\n    name: 'Department missing',\n    category: 'Employee Identity & Context',\n    severity: 'info',\n    confidence: 0.8,\n    confidenceLevel: 'MODERATE',\n    condition: (ctx) => {\n      const dept = ctx.current.department;\n      return dept == null || String(dept).trim() === '';\n    },\n    explanation: 'Department not populated',\n    userAction: 'Optional update',\n    columnsUsed: ['Department'],\n    minTier: 'pro',\n    flagReason: 'Department field is blank for this employee.',\n    riskStatement: 'Missing department data limits reporting and cost-center allocation accuracy.',\n    commonCauses: [\n      'Field not included in the payroll export',\n      'Employee not assigned to a department in HRIS',\n      'New hire setup incomplete',\n    ],\n    reviewSteps: [\n      'Assign a department in your HR system if applicable',\n      'This is informational and does not block approval',\n    ],\n  },\n];\n\nconst hoursComponentsRules = [\n  {\n    id: 'ZERO_HOURS_WITH_PAY',\n    name: 'Zero hours with pay',\n    category: 'Hours Components',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const hours = ctx.current.total_hours_worked;\n      const gross = ctx.current.gross_pay;\n      return hours != null && hours === 0 && gross != null && gross > 0;\n    },\n    explanation: 'Pay without hours detected',\n    userAction: 'Add hours or confirm salaried',\n    columnsUsed: ['TotalHoursWorked', 'GrossPay'],\n    minTier: 'pro',\n    flagReason: 'Employee has zero hours reported but is receiving pay.',\n    riskStatement: 'Zero hours with pay may indicate missing timekeeping data or incorrect salaried classification.',\n    commonCauses: [\n      'Timesheet not submitted before payroll cutoff',\n      'Salaried employee incorrectly classified as hourly',\n      'Hours field not mapped from source system',\n      'Leave taken but hours not recorded',\n    ],\n    reviewSteps: [\n      'Determine if the employee is salaried or hourly',\n      'If hourly, obtain and enter the correct hours',\n      'If salaried, confirm hours are not required',\n      'Verify timesheet submission status',\n    ],\n  },\n  {\n    id: 'TOTAL_HOURS_ZERO_ACTIVE',\n    name: 'Total hours =0 for active employee',\n    category: 'Hours Components',\n    severity: 'info',\n    confidence: 0.8,\n    confidenceLevel: 'MODERATE',\n    condition: (ctx) => {\n      const hours = ctx.current.total_hours_worked;\n      const status = ctx.current.employment_status;\n      return hours != null && hours === 0 && status != null && status.toLowerCase() === 'active';\n    },\n    explanation: 'Total hours =0 for active employee.',\n    userAction: 'No action if on unpaid leave.',\n    columnsUsed: ['TotalHoursWorked', 'Employment_Status'],\n    minTier: 'pro',\n    flagReason: 'An active employee has zero total hours in the current period.',\n    riskStatement: 'May indicate missed timekeeping or unpaid leave not properly flagged.',\n    commonCauses: [\n      'Employee on unpaid leave',\n      'Timesheet not yet submitted',\n      'Salaried employee with no hours tracking',\n    ],\n    reviewSteps: [\n      'Check if the employee is on leave',\n      'Verify timesheet submission status',\n      'No action needed if this is expected',\n    ],\n  },\n  {\n    id: 'NEGATIVE_HOURS',\n    name: 'Negative hours',\n    category: 'Hours Components',\n    severity: 'blocker',\n    confidence: 0.99,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const reg = ctx.current.regular_hours;\n      const ot = ctx.current.overtime_hours;\n      const other = ctx.current.other_paid_hours;\n      return (reg != null && reg < 0) || (ot != null && ot < 0) || (other != null && other < 0);\n    },\n    explanation: 'Negative hours are invalid',\n    userAction: 'Correct time data',\n    columnsUsed: ['RegularHours', 'OvertimeHours', 'OtherPaidHours'],\n    minTier: 'pro',\n    flagReason: 'One or more hours fields contain negative values.',\n    riskStatement: 'Negative hours are not valid in payroll and indicate data entry or system errors.',\n    commonCauses: [\n      'Retroactive time adjustment entered incorrectly',\n      'System error during time import',\n      'Manual correction with wrong sign',\n    ],\n    reviewSteps: [\n      'Identify which hours field is negative',\n      'Determine the intended adjustment',\n      'Correct the value to a non-negative number',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'HOURS_EXCEED_MAX',\n    name: 'Hours exceed plausible max',\n    category: 'Hours Components',\n    severity: 'blocker',\n    confidence: 0.96,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const hours = ctx.current.total_hours_worked;\n      return hours != null && hours > 168;\n    },\n    explanation: 'Hours exceed weekly maximum',\n    userAction: 'Correct time entry',\n    columnsUsed: ['TotalHoursWorked'],\n    minTier: 'pro',\n    flagReason: 'Total hours exceed 168 (the maximum possible hours in a 7-day week).',\n    riskStatement: 'Hours above the physical weekly maximum indicate data entry errors that will cause overpayments.',\n    commonCauses: [\n      'Hours entered for wrong pay period length',\n      'Decimal point error (e.g., 800 instead of 80)',\n      'Multiple weeks of hours summed into one field',\n      'System import error',\n    ],\n    reviewSteps: [\n      'Verify the pay period length (weekly, bi-weekly, etc.)',\n      'Check for data entry or decimal errors',\n      'Correct the hours to the actual amount worked',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'HOURS_SUM_MISMATCH',\n    name: 'TotalHoursWorked != sum of regular/OT/other',\n    category: 'Hours Components',\n    severity: 'blocker',\n    confidence: 0.96,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const total = ctx.current.total_hours_worked;\n      const reg = ctx.current.regular_hours ?? 0;\n      const ot = ctx.current.overtime_hours ?? 0;\n      const other = ctx.current.other_paid_hours ?? 0;\n      if (total == null) return false;\n      const sum = reg + ot + other;\n      return Math.abs(total - sum) > 0.01;\n    },\n    explanation: 'TotalHoursWorked != sum of regular/OT/other.',\n    userAction: 'Reconcile hour components.',\n    columnsUsed: ['TotalHoursWorked', 'RegularHours', 'OvertimeHours', 'OtherPaidHours'],\n    minTier: 'pro',\n    flagReason: 'Total hours do not equal the sum of regular, overtime, and other hours.',\n    riskStatement: 'Hours component mismatch causes incorrect pay calculations and audit failures.',\n    commonCauses: [\n      'Missing hours category not included',\n      'Rounding differences between source systems',\n      'Manual total entered without updating components',\n      'PTO or holiday hours not categorized',\n    ],\n    reviewSteps: [\n      'Compare total hours against the sum of components',\n      'Identify the missing or incorrect component',\n      'Correct the values so they reconcile',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'MATERIAL_HOURS_INCREASE',\n    name: 'Material hours increase',\n    category: 'Hours Components',\n    severity: 'review',\n    confidence: 0.94,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'total_hours_worked' || !ctx.baseline) return false;\n      const bHours = ctx.baseline.total_hours_worked;\n      const cHours = ctx.current.total_hours_worked;\n      return bHours != null && bHours > 0 && cHours != null && cHours >= bHours * 2;\n    },\n    explanation: 'Hours doubled from last payroll',\n    userAction: 'Confirm overtime',\n    columnsUsed: ['TotalHoursWorked'],\n    minTier: 'pro',\n    flagReason: 'Total hours worked increased by 100% or more compared to the previous period.',\n    riskStatement: 'A doubling of hours may indicate overtime errors, duplicate entries, or data issues.',\n    commonCauses: [\n      'Significant overtime approved for this period',\n      'Part-time employee moved to full-time',\n      'Prior period had reduced hours (leave, holiday)',\n      'Data entry error or duplicate time entries',\n    ],\n    reviewSteps: [\n      'Verify overtime was actually worked and approved',\n      'Check if prior period had reduced hours for a valid reason',\n      'Confirm there are no duplicate time entries',\n      'Validate the hours against timekeeping records',\n    ],\n  },\n  {\n    id: 'MATERIAL_HOURS_DECREASE',\n    name: 'Material hours decrease',\n    category: 'Hours Components',\n    severity: 'review',\n    confidence: 0.92,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'total_hours_worked' || !ctx.baseline) return false;\n      const bHours = ctx.baseline.total_hours_worked;\n      const cHours = ctx.current.total_hours_worked;\n      return bHours != null && bHours > 0 && cHours != null && cHours <= bHours * 0.5;\n    },\n    explanation: 'Significant drop in hours',\n    userAction: 'Confirm schedule',\n    columnsUsed: ['TotalHoursWorked'],\n    minTier: 'pro',\n    flagReason: 'Total hours dropped by 50% or more compared to the previous period.',\n    riskStatement: 'A large hours decrease may mean missing timesheets or unreported leave.',\n    commonCauses: [\n      'Employee took leave or vacation',\n      'Schedule reduced (full-time to part-time)',\n      'Timesheet not submitted in time',\n      'Data truncation or import error',\n    ],\n    reviewSteps: [\n      'Verify the employee schedule for this period',\n      'Check for approved leave or time off',\n      'Confirm timesheet was fully submitted',\n      'Validate against timekeeping system records',\n    ],\n  },\n  {\n    id: 'OVERTIME_WITHOUT_REGULAR',\n    name: 'Overtime without regular hours',\n    category: 'Hours Components',\n    severity: 'review',\n    confidence: 0.93,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const ot = ctx.current.overtime_hours;\n      const reg = ctx.current.regular_hours;\n      return ot != null && ot > 0 && (reg == null || reg === 0);\n    },\n    explanation: 'Overtime logged without regular hours',\n    userAction: 'Verify OT entry',\n    columnsUsed: ['RegularHours', 'OvertimeHours'],\n    minTier: 'pro',\n    flagReason: 'Employee has overtime hours but no regular hours recorded.',\n    riskStatement: 'Overtime without regular hours is unusual and often indicates a data classification error.',\n    commonCauses: [\n      'Regular hours classified as overtime',\n      'Hours field mapping error during import',\n      'Employee only worked callback/on-call hours',\n      'Time categorization rules misconfigured',\n    ],\n    reviewSteps: [\n      'Review the employee time records',\n      'Verify hours are categorized correctly',\n      'Check if regular hours should be populated',\n      'Correct the classification if needed',\n    ],\n  },\n  {\n    id: 'PAID_HOURS_EXCEED_TOTAL',\n    name: 'Paid hours exceed total',\n    category: 'Hours Components',\n    severity: 'blocker',\n    confidence: 0.98,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const total = ctx.current.total_hours_worked;\n      const reg = ctx.current.regular_hours ?? 0;\n      const ot = ctx.current.overtime_hours ?? 0;\n      const other = ctx.current.other_paid_hours ?? 0;\n      if (total == null) return false;\n      return (reg + ot + other) > total + 0.01;\n    },\n    explanation: 'Paid hours exceed total',\n    userAction: 'Fix breakdown',\n    columnsUsed: ['RegularHours', 'OvertimeHours', 'OtherPaidHours', 'TotalHoursWorked'],\n    minTier: 'pro',\n    flagReason: 'The sum of paid hours components exceeds total hours worked.',\n    riskStatement: 'Overstated paid hours lead to overpayments and incorrect labor cost allocation.',\n    commonCauses: [\n      'Double-counted hours across categories',\n      'PTO hours added on top of worked hours',\n      'Total hours field not updated after corrections',\n    ],\n    reviewSteps: [\n      'Compare the sum of hour components against the total',\n      'Identify the double-counted category',\n      'Correct the totals to match',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'PTO_SPIKE',\n    name: 'PTO spike',\n    category: 'Hours Components',\n    severity: 'info',\n    confidence: 0.85,\n    confidenceLevel: 'MODERATE',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bOther = ctx.baseline.other_paid_hours;\n      const cOther = ctx.current.other_paid_hours;\n      return bOther != null && bOther > 0 && cOther != null && cOther >= bOther * 2;\n    },\n    explanation: 'PTO spike detected',\n    userAction: 'FYI only',\n    columnsUsed: ['OtherPaidHours'],\n    minTier: 'pro',\n    flagReason: 'Other paid hours (PTO/leave) doubled or more from the previous period.',\n    riskStatement: 'Large PTO spikes are often expected but worth noting for budget and coverage planning.',\n    commonCauses: [\n      'Year-end PTO usage before expiration',\n      'Extended vacation or personal leave',\n      'Company holiday week',\n    ],\n    reviewSteps: [\n      'Verify the PTO usage is approved',\n      'No action needed if this is expected',\n    ],\n  },\n];\n\nconst earningsComponentsRules = [\n  {\n    id: 'BASE_EARNINGS_DROPPED_20PCT',\n    name: 'Base earnings dropped >=20%',\n    category: 'Earnings Components',\n    severity: 'review',\n    confidence: 0.92,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'base_earnings' || !ctx.baseline) return false;\n      const b = ctx.baseline.base_earnings;\n      const c = ctx.current.base_earnings;\n      if (b == null || b === 0 || c == null) return false;\n      return ((c - b) / Math.abs(b)) * 100 <= -20;\n    },\n    explanation: 'Base pay reduced significantly',\n    userAction: 'Confirm rate/hours',\n    columnsUsed: ['Base_Earnings'],\n    minTier: 'pro',\n    flagReason: 'Base earnings decreased by 20% or more compared to the previous period.',\n    riskStatement: 'Significant base pay reductions may indicate missing hours, rate changes, or data errors.',\n    commonCauses: [\n      'Pay rate reduction or demotion',\n      'Reduced hours or schedule change',\n      'Incorrect rate applied for the period',\n      'Partial period pay (start/end mid-period)',\n    ],\n    reviewSteps: [\n      'Verify the employee pay rate is correct',\n      'Check if hours worked decreased this period',\n      'Confirm any authorized salary changes',\n      'Review for partial period adjustments',\n    ],\n  },\n  {\n    id: 'BASE_EARNINGS_SPIKE_50PCT',\n    name: 'Base earnings spike >=50%',\n    category: 'Earnings Components',\n    severity: 'review',\n    confidence: 0.93,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'base_earnings' || !ctx.baseline) return false;\n      const b = ctx.baseline.base_earnings;\n      const c = ctx.current.base_earnings;\n      if (b == null || b === 0 || c == null) return false;\n      return ((c - b) / Math.abs(b)) * 100 >= 50;\n    },\n    explanation: 'Base pay spike detected',\n    userAction: 'Verify comp change',\n    columnsUsed: ['Base_Earnings'],\n    minTier: 'pro',\n    flagReason: 'Base earnings increased by 50% or more compared to the previous period.',\n    riskStatement: 'Large base pay increases may indicate unauthorized rate changes or data entry errors.',\n    commonCauses: [\n      'Promotion or significant raise',\n      'Prior period had reduced hours',\n      'Retroactive pay adjustment included',\n      'Incorrect rate or hours entered',\n    ],\n    reviewSteps: [\n      'Verify the pay rate change is authorized',\n      'Check if retroactive adjustments are included',\n      'Compare hours worked between periods',\n      'Confirm with HR if this is a valid compensation change',\n    ],\n  },\n  {\n    id: 'OVERTIME_PAY_WITHOUT_OT_HOURS',\n    name: 'Overtime pay without OT hours',\n    category: 'Earnings Components',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const otPay = ctx.current.overtime_pay;\n      const otHours = ctx.current.overtime_hours;\n      return otPay != null && otPay > 0 && (otHours == null || otHours === 0);\n    },\n    explanation: 'OT pay without OT hours',\n    userAction: 'Fix OT setup',\n    columnsUsed: ['OvertimePay', 'OvertimeHours'],\n    minTier: 'pro',\n    flagReason: 'Overtime pay is recorded but no overtime hours are logged.',\n    riskStatement: 'Overtime pay without corresponding hours is a common audit finding and may violate FLSA requirements.',\n    commonCauses: [\n      'Overtime hours field not mapped from source system',\n      'Flat overtime payment entered without hours',\n      'Hours classified under regular instead of overtime',\n      'System import error',\n    ],\n    reviewSteps: [\n      'Verify if overtime hours should be recorded',\n      'Check the source system for correct OT hours',\n      'Ensure hours and pay fields are properly mapped',\n      'Correct the hours or reclassify the pay',\n    ],\n  },\n  {\n    id: 'BONUS_PAID_UNEXPECTEDLY',\n    name: 'Bonus paid unexpectedly',\n    category: 'Earnings Components',\n    severity: 'review',\n    confidence: 0.88,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bBonus = ctx.baseline.bonus_earnings;\n      const cBonus = ctx.current.bonus_earnings;\n      return (bBonus == null || bBonus === 0) && cBonus != null && cBonus > 0;\n    },\n    explanation: 'Bonus introduced this run',\n    userAction: 'Confirm approval',\n    columnsUsed: ['Bonus_Earnings'],\n    minTier: 'pro',\n    flagReason: 'A bonus payment appeared this period that was not present in the previous period.',\n    riskStatement: 'Unverified bonus payments may be unauthorized, duplicated, or entered in error.',\n    commonCauses: [\n      'Approved performance or signing bonus',\n      'Referral bonus payout',\n      'Bonus entered for wrong employee',\n      'Duplicate bonus from previous cycle',\n    ],\n    reviewSteps: [\n      'Verify the bonus is authorized and documented',\n      'Confirm the correct employee received it',\n      'Check that it was not already paid in a prior period',\n      'Validate the bonus amount',\n    ],\n  },\n  {\n    id: 'OTHER_EARNINGS_HIGH',\n    name: 'Other earnings unusually high',\n    category: 'Earnings Components',\n    severity: 'review',\n    confidence: 0.86,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline) return false;\n      const bOther = ctx.baseline.other_earnings;\n      const cOther = ctx.current.other_earnings;\n      if (bOther == null || bOther === 0) return cOther != null && cOther > 1000;\n      return cOther != null && cOther >= bOther * 2;\n    },\n    explanation: 'Other earnings unusually high',\n    userAction: 'Review earning code',\n    columnsUsed: ['Other_Earnings'],\n    minTier: 'pro',\n    flagReason: 'Other earnings are significantly higher than the previous period or exceed $1,000.',\n    riskStatement: 'Unusual other earnings may indicate miscoded payments, duplicate entries, or unauthorized additions.',\n    commonCauses: [\n      'Commissions or reimbursements paid this period',\n      'Retroactive adjustment included',\n      'Payment miscoded to other earnings',\n      'Duplicate or unauthorized payment',\n    ],\n    reviewSteps: [\n      'Identify the earning codes making up other earnings',\n      'Verify each earning is authorized',\n      'Check for duplicate entries',\n      'Confirm proper coding of the earnings',\n    ],\n  },\n  {\n    id: 'EARNINGS_NEGATIVE',\n    name: 'Earnings negative',\n    category: 'Earnings Components',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const fields = ['base_earnings', 'overtime_pay', 'bonus_earnings', 'other_earnings'];\n      return fields.some(f => {\n        const val = ctx.current[f];\n        return val != null && val < 0;\n      });\n    },\n    explanation: 'Negative earnings invalid',\n    userAction: 'Correct values',\n    columnsUsed: ['Base_Earnings', 'OvertimePay', 'Bonus_Earnings', 'Other_Earnings'],\n    minTier: 'starter',\n    flagReason: 'One or more earnings fields contain negative values.',\n    riskStatement: 'Negative earnings are invalid in standard payroll and indicate data entry or system errors.',\n    commonCauses: [\n      'Retroactive adjustment entered with wrong sign',\n      'Overpayment recovery entered as negative earning instead of deduction',\n      'System calculation error',\n      'Manual entry error',\n    ],\n    reviewSteps: [\n      'Identify which earnings field is negative',\n      'Determine if this should be a deduction instead',\n      'Correct the value or reclassify the entry',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'EARNINGS_WITHOUT_EMPLOYEE',\n    name: 'Earnings without employee mapping',\n    category: 'Earnings Components',\n    severity: 'blocker',\n    confidence: 0.99,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const empId = ctx.current.employee_id;\n      const hasEarnings = ['base_earnings', 'overtime_pay', 'bonus_earnings', 'other_earnings'].some(f => {\n        const val = ctx.current[f];\n        return val != null && val > 0;\n      });\n      return hasEarnings && (empId == null || String(empId).trim() === '');\n    },\n    explanation: 'Earnings without employee mapping',\n    userAction: 'Fix employee data',\n    columnsUsed: ['EmployeeID', 'Base_Earnings'],\n    minTier: 'pro',\n    flagReason: 'Earnings exist for a record without an employee ID.',\n    riskStatement: 'Unassigned earnings cannot be paid, taxed, or reported correctly.',\n    commonCauses: [\n      'Employee ID column missing from export',\n      'Row added manually without an ID',\n      'Data mapping error during import',\n    ],\n    reviewSteps: [\n      'Identify the record with missing employee ID',\n      'Assign the correct employee ID',\n      'Re-upload the corrected file',\n    ],\n  },\n];\n\nconst fundamentalPayRules = [\n  {\n    id: 'NEGATIVE_GROSS_PAY',\n    name: 'Negative gross pay',\n    category: 'Fundamental Pay Components',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const gross = ctx.current.gross_pay;\n      return gross != null && gross < 0;\n    },\n    explanation: 'Negative gross pay.',\n    userAction: 'Correct earnings sum.',\n    columnsUsed: ['GrossPay'],\n    minTier: 'starter',\n    flagReason: 'Gross pay is negative, which is not valid in US payroll processing.',\n    riskStatement: 'Negative gross pay indicates a fundamental calculation error that will cascade through taxes, deductions, and net pay.',\n    commonCauses: [\n      'Retroactive adjustment exceeds current gross',\n      'Overpayment recovery exceeds current earnings',\n      'Earnings entered with wrong sign',\n      'System calculation error',\n    ],\n    reviewSteps: [\n      'Review the earnings breakdown for this employee',\n      'Identify any retroactive adjustments or corrections',\n      'Verify earnings components sum correctly',\n      'Correct the values and re-upload',\n    ],\n  },\n  {\n    id: 'NET_PAY_NEGATIVE',\n    name: 'Negative Net Pay',\n    category: 'Fundamental Pay Components',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const net = ctx.current.net_pay;\n      return net != null && net < 0;\n    },\n    explanation: 'Net pay cannot be negative',\n    userAction: 'Fix taxes/deductions',\n    columnsUsed: ['NetPay'],\n    minTier: 'starter',\n    flagReason: 'Negative net pay is not permitted in US payroll processing.',\n    riskStatement: 'This can result in incorrect employee compensation, compliance violations, and failed payroll submission.',\n    commonCauses: [\n      'Garnishment exceeds allowable limits',\n      'Retroactive deduction applied more than once',\n      'Manual adjustment entered as deduction instead of earning',\n      'Deduction caps not enforced',\n    ],\n    reviewSteps: [\n      'Review garnishment limits for this employee',\n      'Verify recent retroactive adjustments',\n      'Check manual earnings and deduction entries',\n      'Confirm deduction caps and priorities',\n    ],\n  },\n  {\n    id: 'NET_PAY_UNUSUALLY_LOW',\n    name: 'Net pay unusually low',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.89,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const net = ctx.current.net_pay;\n      const gross = ctx.current.gross_pay;\n      return net != null && gross != null && gross > 0 && net < gross * 0.4;\n    },\n    explanation: 'Net pay unusually low',\n    userAction: 'Review deductions',\n    columnsUsed: ['NetPay', 'GrossPay'],\n    minTier: 'pro',\n    flagReason: 'Net pay is less than 40% of gross pay, which is unusually low.',\n    riskStatement: 'Very low net-to-gross ratios often indicate excessive deductions or incorrect tax withholding.',\n    commonCauses: [\n      'New benefit enrollment with high premiums',\n      'Additional tax withholding (W-4 change)',\n      'Garnishment or levy applied',\n      'Duplicate deduction applied',\n    ],\n    reviewSteps: [\n      'Review all deductions for this employee',\n      'Check for new or changed benefit elections',\n      'Verify tax withholding amounts',\n      'Look for duplicate or excessive deductions',\n    ],\n  },\n  {\n    id: 'GROSS_LESS_THAN_NET',\n    name: 'GrossPay < NetPay',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.89,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const gross = ctx.current.gross_pay;\n      const net = ctx.current.net_pay;\n      return gross != null && net != null && gross < net;\n    },\n    explanation: 'GrossPay < NetPay',\n    userAction: 'Fix calculation error.',\n    columnsUsed: ['GrossPay', 'NetPay'],\n    minTier: 'starter',\n    flagReason: 'Net pay exceeds gross pay, which should not happen after taxes and deductions.',\n    riskStatement: 'This indicates a fundamental math error in the payroll calculation or data entry.',\n    commonCauses: [\n      'Negative taxes or deductions applied',\n      'Reimbursement added to net but not gross',\n      'Gross and net columns swapped in the file',\n      'Data import mapping error',\n    ],\n    reviewSteps: [\n      'Verify gross and net pay values are in the correct columns',\n      'Check for negative tax or deduction values',\n      'Ensure reimbursements are properly classified',\n      'Correct the calculation and re-upload',\n    ],\n  },\n  {\n    id: 'NET_PAY_SPIKE_50PCT',\n    name: 'Net pay spike >=50%',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.89,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'net_pay') return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage >= 50;\n    },\n    explanation: 'Net pay increased by 50% or more.',\n    userAction: 'Check for underwithholding or earnings spike.',\n    columnsUsed: ['NetPay'],\n    minTier: 'starter',\n    flagReason: 'Net pay increased by 50% or more compared to the previous period.',\n    riskStatement: 'Large net pay increases may indicate underwithholding, duplicate payments, or unauthorized earnings.',\n    commonCauses: [\n      'Bonus or commission paid this period',\n      'Tax withholding decreased significantly',\n      'Deduction removed or reduced',\n      'Overtime or supplemental pay included',\n    ],\n    reviewSteps: [\n      'Compare earnings between periods',\n      'Check for changes in tax withholding',\n      'Verify deduction changes',\n      'Confirm any bonus or supplemental payments',\n    ],\n  },\n  {\n    id: 'NET_PAY_DROP_20PCT',\n    name: 'Net pay drop >=20%',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.89,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'net_pay') return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage <= -20;\n    },\n    explanation: 'Net pay decreased by 20% or more.',\n    userAction: 'Verify tax/deduction changes.',\n    columnsUsed: ['NetPay'],\n    minTier: 'starter',\n    flagReason: 'Net pay decreased by 20% or more compared to the previous period.',\n    riskStatement: 'Significant net pay drops often trigger employee complaints and may indicate calculation errors.',\n    commonCauses: [\n      'New benefit enrollment or rate increase',\n      'Additional tax withholding',\n      'Garnishment or levy initiated',\n      'Reduced hours or earnings',\n    ],\n    reviewSteps: [\n      'Identify the source of the decrease (earnings, taxes, or deductions)',\n      'Check for new or changed benefit elections',\n      'Verify tax withholding changes',\n      'Confirm with the employee if needed',\n    ],\n  },\n  {\n    id: 'GROSS_NOT_EQUAL_EARNINGS_SUM',\n    name: 'Gross != earnings sum',\n    category: 'Fundamental Pay Components',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const gross = ctx.current.gross_pay;\n      const base = ctx.current.base_earnings ?? 0;\n      const ot = ctx.current.overtime_pay ?? 0;\n      const bonus = ctx.current.bonus_earnings ?? 0;\n      const other = ctx.current.other_earnings ?? 0;\n      if (gross == null) return false;\n      if (base === 0 && ot === 0 && bonus === 0 && other === 0) return false;\n      const sum = base + ot + bonus + other;\n      return Math.abs(gross - sum) > 0.01;\n    },\n    explanation: 'Gross does not match earnings',\n    userAction: 'Fix calculation',\n    columnsUsed: ['GrossPay', 'Base_Earnings', 'OvertimePay', 'Bonus_Earnings', 'Other_Earnings'],\n    minTier: 'pro',\n    flagReason: 'Gross pay does not equal the sum of earnings components (base + OT + bonus + other).',\n    riskStatement: 'Earnings-to-gross mismatches indicate missing or duplicated earnings that affect tax and deduction calculations.',\n    commonCauses: [\n      'Earnings component not included in the export',\n      'Gross manually overridden without updating components',\n      'Rounding differences across systems',\n      'Additional earning type not categorized',\n    ],\n    reviewSteps: [\n      'Compare gross pay to the sum of all earnings components',\n      'Identify the missing or extra amount',\n      'Verify all earning codes are mapped to a component',\n      'Correct the values so they reconcile',\n    ],\n  },\n  {\n    id: 'GROSS_PAY_SPIKE_50PCT',\n    name: 'Gross pay spike >=50%',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.93,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'gross_pay') return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage >= 50;\n    },\n    explanation: 'Gross pay spike detected',\n    userAction: 'Review earnings',\n    columnsUsed: ['GrossPay'],\n    minTier: 'starter',\n    flagReason: 'Gross pay increased by 50% or more compared to the previous period.',\n    riskStatement: 'Large gross pay spikes may indicate duplicate payments, unauthorized rate changes, or data errors.',\n    commonCauses: [\n      'Bonus or commission included this period',\n      'Significant overtime worked',\n      'Retroactive pay adjustment',\n      'Rate increase or promotion',\n    ],\n    reviewSteps: [\n      'Review the earnings breakdown for this period',\n      'Compare hours and rates between periods',\n      'Verify any bonuses or supplemental pay',\n      'Confirm the increase is authorized',\n    ],\n  },\n  {\n    id: 'GROSS_PAY_DROP_30PCT',\n    name: 'Gross pay drop >=30%',\n    category: 'Fundamental Pay Components',\n    severity: 'review',\n    confidence: 0.91,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'gross_pay') return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage <= -30;\n    },\n    explanation: 'Gross pay dropped significantly',\n    userAction: 'Confirm changes',\n    columnsUsed: ['GrossPay'],\n    minTier: 'starter',\n    flagReason: 'Gross pay decreased by 30% or more compared to the previous period.',\n    riskStatement: 'Significant gross pay reductions are uncommon and may indicate missing earnings or hours.',\n    commonCauses: [\n      'Missing hours or earnings for this period',\n      'Rate change or demotion',\n      'Unpaid leave taken',\n      'Partial period pay (hire or termination mid-period)',\n    ],\n    reviewSteps: [\n      'Verify hours worked for this period',\n      'Check for rate changes or adjustments',\n      'Confirm leave status',\n      'Ensure all earnings are included in the file',\n    ],\n  },\n];\n\nconst taxesComponentsRules = [\n  {\n    id: 'NEGATIVE_TAXES',\n    name: 'Negative taxes',\n    category: 'Taxes Components',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const fields = ['federal_income_tax', 'social_security_tax', 'medicare_tax', 'state_income_tax', 'local_tax'];\n      return fields.some(f => {\n        const val = ctx.current[f];\n        return val != null && val < 0;\n      });\n    },\n    explanation: 'Taxes < 0',\n    userAction: 'Correct W-4 or calculation.',\n    columnsUsed: ['FederalIncomeTaxWithheld', 'SocialSecurityWithheld', 'MedicareWithheld', 'StateIncomeTaxWithheld', 'LocalTaxWithheld'],\n    minTier: 'starter',\n    flagReason: 'One or more tax withholding fields contain negative values.',\n    riskStatement: 'Negative tax values are invalid and will cause incorrect filings and potential penalties.',\n    commonCauses: [\n      'Prior period tax correction entered with wrong sign',\n      'System error during tax calculation',\n      'Manual adjustment to tax withholding entered incorrectly',\n      'Import mapping error (deduction vs. tax)',\n    ],\n    reviewSteps: [\n      'Identify which tax field is negative',\n      'Determine the intended adjustment',\n      'Correct the value to a non-negative number',\n      'Re-upload the corrected file',\n    ],\n  },\n  {\n    id: 'MISSING_FEDERAL_TAX',\n    name: 'Missing federal tax',\n    category: 'Taxes Components',\n    severity: 'blocker',\n    confidence: 0.97,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const fed = ctx.current.federal_income_tax;\n      const gross = ctx.current.gross_pay;\n      return (fed == null || fed === 0) && gross != null && gross > 500;\n    },\n    explanation: 'Federal tax missing',\n    userAction: 'Verify tax setup',\n    columnsUsed: ['FederalIncomeTaxWithheld', 'GrossPay'],\n    minTier: 'pro',\n    flagReason: 'No federal income tax withheld for an employee with gross pay over $500.',\n    riskStatement: 'Missing federal tax withholding may result in IRS penalties for both employer and employee.',\n    commonCauses: [\n      'Employee claimed exempt on W-4',\n      'W-4 not yet submitted for new hire',\n      'Tax setup incomplete in payroll system',\n      'Tax field not mapped in data export',\n    ],\n    reviewSteps: [\n      'Check the employee W-4 filing status',\n      'Verify if the employee is legitimately exempt',\n      'Confirm the tax setup in your payroll system',\n      'If exempt, document the reason; otherwise fix the withholding',\n    ],\n  },\n  {\n    id: 'MISSING_FICA_TAXES',\n    name: 'Missing FICA taxes',\n    category: 'Taxes Components',\n    severity: 'blocker',\n    confidence: 0.96,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const ss = ctx.current.social_security_tax;\n      const med = ctx.current.medicare_tax;\n      const gross = ctx.current.gross_pay;\n      return ((ss == null || ss === 0) || (med == null || med === 0)) && gross != null && gross > 500;\n    },\n    explanation: 'FICA tax missing',\n    userAction: 'Fix tax config',\n    columnsUsed: ['SocialSecurityWithheld', 'MedicareWithheld', 'GrossPay'],\n    minTier: 'pro',\n    flagReason: 'Social Security or Medicare tax is missing for an employee with significant gross pay.',\n    riskStatement: 'FICA taxes are mandatory for most employees. Missing FICA creates compliance risk and IRS reporting errors.',\n    commonCauses: [\n      'Employee incorrectly classified as FICA-exempt',\n      'Tax setup not completed for new hire',\n      'Student or religious worker exemption not documented',\n      'Tax field not mapped in data export',\n    ],\n    reviewSteps: [\n      'Verify if the employee qualifies for FICA exemption',\n      'Check the tax configuration in your payroll system',\n      'Ensure both SS and Medicare fields are populated',\n      'Document any valid exemptions',\n    ],\n  },\n  {\n    id: 'TAX_SPIKE_40PCT',\n    name: 'Tax spike >=40%',\n    category: 'Taxes Components',\n    severity: 'review',\n    confidence: 0.9,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const taxMetrics = ['federal_income_tax', 'social_security_tax', 'medicare_tax', 'state_income_tax', 'local_tax'];\n      if (!taxMetrics.includes(ctx.metric) || !ctx.baseline) return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage >= 40;\n    },\n    explanation: 'Tax spike detected',\n    userAction: 'Review filing status',\n    columnsUsed: ['FederalIncomeTaxWithheld', 'SocialSecurityWithheld', 'MedicareWithheld', 'StateIncomeTaxWithheld', 'LocalTaxWithheld'],\n    minTier: 'pro',\n    flagReason: 'Tax withholding increased by 40% or more compared to the previous period.',\n    riskStatement: 'Large tax increases may indicate W-4 changes, supplemental pay tax treatment, or calculation errors.',\n    commonCauses: [\n      'Employee updated W-4 withholding',\n      'Supplemental pay taxed at flat rate',\n      'Earnings increase pushed into higher bracket',\n      'State residency change',\n    ],\n    reviewSteps: [\n      'Check for W-4 or withholding changes',\n      'Verify if earnings increased significantly',\n      'Confirm the tax calculation method used',\n      'Review for supplemental pay tax treatment',\n    ],\n  },\n  {\n    id: 'TAX_DROP_30PCT',\n    name: 'Tax drop >=30%',\n    category: 'Taxes Components',\n    severity: 'review',\n    confidence: 0.89,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const taxMetrics = ['federal_income_tax', 'social_security_tax', 'medicare_tax', 'state_income_tax', 'local_tax'];\n      if (!taxMetrics.includes(ctx.metric) || !ctx.baseline) return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage <= -30;\n    },\n    explanation: 'Tax drop detected',\n    userAction: 'Confirm exemptions',\n    columnsUsed: ['FederalIncomeTaxWithheld', 'SocialSecurityWithheld', 'MedicareWithheld', 'StateIncomeTaxWithheld', 'LocalTaxWithheld'],\n    minTier: 'pro',\n    flagReason: 'Tax withholding decreased by 30% or more compared to the previous period.',\n    riskStatement: 'Significant tax decreases may result in underwithholding and year-end tax liabilities for employees.',\n    commonCauses: [\n      'Employee increased allowances or claimed exempt',\n      'Earnings decreased this period',\n      'Pre-tax deduction increased (FSA, HSA, 401k)',\n      'Tax calculation error',\n    ],\n    reviewSteps: [\n      'Check for W-4 or withholding changes',\n      'Verify if earnings decreased',\n      'Review pre-tax deduction changes',\n      'Confirm the tax calculation is correct',\n    ],\n  },\n  {\n    id: 'STATE_TAX_MISSING',\n    name: 'State tax missing',\n    category: 'Taxes Components',\n    severity: 'review',\n    confidence: 0.88,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      const stateTax = ctx.current.state_income_tax;\n      const gross = ctx.current.gross_pay;\n      return (stateTax == null || stateTax === 0) && gross != null && gross > 500;\n    },\n    explanation: 'State tax missing',\n    userAction: 'Check state setup',\n    columnsUsed: ['StateIncomeTaxWithheld'],\n    minTier: 'pro',\n    flagReason: 'No state income tax withheld for an employee with significant gross pay.',\n    riskStatement: 'Missing state tax may indicate incorrect work state setup or an employee in a no-income-tax state.',\n    commonCauses: [\n      'Employee works in a state with no income tax',\n      'State tax setup not completed',\n      'Work state not assigned in payroll system',\n      'Remote worker state not updated',\n    ],\n    reviewSteps: [\n      'Verify the employee work state',\n      'Check if the state has income tax',\n      'If applicable, set up state tax withholding',\n      'Document if the employee is in a no-income-tax state',\n    ],\n  },\n  {\n    id: 'LOCAL_TAX_INCONSISTENCY',\n    name: 'Local tax inconsistency',\n    category: 'Taxes Components',\n    severity: 'info',\n    confidence: 0.82,\n    confidenceLevel: 'MODERATE',\n    condition: (ctx) => {\n      if (!ctx.allCurrentEmployees) return false;\n      const hasLocal = ctx.current.local_tax != null && ctx.current.local_tax > 0;\n      if (!hasLocal) return false;\n      const totalWithLocal = ctx.allCurrentEmployees.filter(e => e.local_tax != null && e.local_tax > 0).length;\n      const total = ctx.allCurrentEmployees.length;\n      return total > 5 && totalWithLocal / total < 0.3;\n    },\n    explanation: 'Local tax inconsistency',\n    userAction: 'FYI',\n    columnsUsed: ['LocalTaxWithheld'],\n    minTier: 'pro',\n    flagReason: 'Less than 30% of employees have local tax, suggesting inconsistent tax jurisdiction setup.',\n    riskStatement: 'Inconsistent local tax setup may cause compliance issues in jurisdictions that require it.',\n    commonCauses: [\n      'Employees in different jurisdictions with varying local tax requirements',\n      'Local tax setup incomplete for some employees',\n      'Recent office relocation affecting tax jurisdictions',\n    ],\n    reviewSteps: [\n      'Review local tax jurisdiction assignments',\n      'Verify which employees should have local tax withheld',\n      'This is informational and does not block approval',\n    ],\n  },\n];\n\nconst deductionsComponentsRules = [\n  {\n    id: 'DEDUCTIONS_EXCEED_GROSS',\n    name: 'Deductions exceed gross',\n    category: 'Deductions Components',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const ded = ctx.current.total_deductions;\n      const gross = ctx.current.gross_pay;\n      return ded != null && gross != null && ded > gross;\n    },\n    explanation: 'Total deductions exceed gross pay',\n    userAction: 'Review deduction setup immediately.',\n    columnsUsed: ['TotalDeductions', 'GrossPay'],\n    minTier: 'starter',\n    flagReason: 'Total deductions exceed gross pay, which would result in negative net pay.',\n    riskStatement: 'Deductions exceeding gross pay cause negative net pay, which is invalid and blocks payroll processing.',\n    commonCauses: [\n      'Retroactive deduction applied in full instead of spread over periods',\n      'Garnishment or levy exceeds disposable earnings limits',\n      'Benefit premiums increased without adjusting deduction caps',\n      'Duplicate deduction applied',\n    ],\n    reviewSteps: [\n      'Review all deductions for this employee',\n      'Check garnishment limits and disposable earnings',\n      'Verify deduction caps are properly configured',\n      'Remove or reduce duplicate or excessive deductions',\n    ],\n  },\n  {\n    id: 'NEW_DEDUCTION_INTRODUCED',\n    name: 'New deduction introduced',\n    category: 'Deductions Components',\n    severity: 'review',\n    confidence: 0.87,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline || !ctx.current.pay_components || !ctx.baseline.pay_components) return false;\n      const baselineTypes = new Set(ctx.baseline.pay_components.map((c) => c.component_name));\n      return ctx.current.pay_components.some(\n        (c) => !baselineTypes.has(c.component_name)\n      );\n    },\n    explanation: 'New deduction type appeared',\n    userAction: 'Verify new deduction is authorized.',\n    columnsUsed: ['DeductionComponents'],\n    minTier: 'pro',\n    flagReason: 'A deduction type appeared in the current run that was not present in the previous run.',\n    riskStatement: 'Unauthorized or unexpected deductions can cause employee complaints and compliance issues.',\n    commonCauses: [\n      'New benefit enrollment (medical, dental, vision)',\n      'Court-ordered garnishment initiated',\n      'Employee elected new voluntary deduction',\n      'Deduction code added in error',\n    ],\n    reviewSteps: [\n      'Identify the new deduction type',\n      'Verify it is authorized by the employee or court order',\n      'Confirm the amount is correct',\n      'Check the effective date',\n    ],\n  },\n  {\n    id: 'DEDUCTION_DROPPED',\n    name: 'Deduction dropped unexpectedly',\n    category: 'Deductions Components',\n    severity: 'review',\n    confidence: 0.86,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.baseline || !ctx.current.pay_components || !ctx.baseline.pay_components) return false;\n      const currentTypes = new Set(ctx.current.pay_components.map((c) => c.component_name));\n      return ctx.baseline.pay_components.some(\n        (c) => !currentTypes.has(c.component_name)\n      );\n    },\n    explanation: 'A deduction from baseline is missing',\n    userAction: 'Confirm deduction removal is intentional.',\n    columnsUsed: ['DeductionComponents'],\n    minTier: 'pro',\n    flagReason: 'A deduction present in the previous run is missing from the current run.',\n    riskStatement: 'Dropped deductions may indicate canceled benefits, missed garnishments, or system configuration errors.',\n    commonCauses: [\n      'Employee terminated benefit enrollment',\n      'Garnishment completed or satisfied',\n      'Deduction code deactivated by mistake',\n      'System migration dropped the deduction',\n    ],\n    reviewSteps: [\n      'Identify the missing deduction',\n      'Verify if the removal is intentional',\n      'If a garnishment, confirm it has been legally satisfied',\n      'Restore the deduction if removed in error',\n    ],\n  },\n  {\n    id: 'DEDUCTION_SPIKE_50PCT',\n    name: 'Deduction spike >=50%',\n    category: 'Deductions Components',\n    severity: 'review',\n    confidence: 0.88,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (ctx.metric !== 'total_deductions' || !ctx.baseline) return false;\n      return ctx.deltaPercentage != null && ctx.deltaPercentage >= 50;\n    },\n    explanation: 'Total deductions spiked >=50%',\n    userAction: 'Review deduction changes.',\n    columnsUsed: ['TotalDeductions'],\n    minTier: 'pro',\n    flagReason: 'Total deductions increased by 50% or more compared to the previous period.',\n    riskStatement: 'Sudden deduction increases often trigger employee complaints and may indicate configuration errors.',\n    commonCauses: [\n      'Open enrollment benefit changes took effect',\n      'Retroactive deduction catch-up',\n      'New garnishment or levy added',\n      'Duplicate deduction applied',\n    ],\n    reviewSteps: [\n      'Compare deduction detail between periods',\n      'Identify which deduction increased',\n      'Verify the increase is authorized',\n      'Check for duplicate deductions',\n    ],\n  },\n  {\n    id: 'NEGATIVE_DEDUCTION',\n    name: 'Negative deduction',\n    category: 'Deductions Components',\n    severity: 'blocker',\n    confidence: 0.99,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const ded = ctx.current.total_deductions;\n      return ded != null && ded < 0;\n    },\n    explanation: 'Deduction amount is negative',\n    userAction: 'Correct deduction configuration.',\n    columnsUsed: ['TotalDeductions'],\n    minTier: 'starter',\n    flagReason: 'Total deductions is negative, which is not valid in standard payroll.',\n    riskStatement: 'Negative deductions inflate net pay and create incorrect tax and benefit records.',\n    commonCauses: [\n      'Refund or reversal entered as negative deduction',\n      'System error in deduction calculation',\n      'Manual adjustment with wrong sign',\n      'Deduction reversal exceeds original amount',\n    ],\n    reviewSteps: [\n      'Verify the deduction amount is correct',\n      'If this is a refund, process it as an earning instead',\n      'Correct the sign and re-upload',\n    ],\n  },\n  {\n    id: 'TOTAL_DEDUCTIONS_SUM_MISMATCH',\n    name: 'TotalDeductions != sum of components',\n    category: 'Deductions Components',\n    severity: 'blocker',\n    confidence: 0.99,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const total = ctx.current.total_deductions;\n      if (total == null || !ctx.current.pay_components || ctx.current.pay_components.length === 0) return false;\n      const sum = ctx.current.pay_components.reduce(\n        (acc, c) => acc + (c.amount || 0),\n        0\n      );\n      return Math.abs(total - sum) > 1;\n    },\n    explanation: 'Total deductions != sum of individual deductions',\n    userAction: 'Reconcile deduction components.',\n    columnsUsed: ['TotalDeductions', 'DeductionComponents'],\n    minTier: 'pro',\n    flagReason: 'The total deductions field does not match the sum of individual deduction components.',\n    riskStatement: 'Deduction mismatches indicate missing or extra deductions that affect net pay accuracy.',\n    commonCauses: [\n      'Deduction component not included in the export',\n      'Total manually entered without updating components',\n      'Rounding differences across deduction types',\n      'Imputed income or employer-paid deduction included in total',\n    ],\n    reviewSteps: [\n      'Compare total deductions to the sum of components',\n      'Identify the missing or extra amount',\n      'Verify all deduction codes are included',\n      'Correct the values so they reconcile',\n    ],\n  },\n  {\n    id: '401K_OVER_IRS_LIMIT',\n    name: '401(k) over IRS limit',\n    category: 'Deductions Components',\n    severity: 'blocker',\n    confidence: 0.95,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      if (!ctx.current.pay_components) return false;\n      const k401 = ctx.current.pay_components.find(\n        (c) =>\n          c.component_name && /401.?k/i.test(c.component_name)\n      );\n      if (!k401) return false;\n      return k401.amount != null && k401.amount > 10000;\n    },\n    explanation: '401(k) contribution exceeds plausible per-period max',\n    userAction: 'Verify 401(k) deduction amount.',\n    columnsUsed: ['DeductionComponents'],\n    minTier: 'pro',\n    flagReason: '401(k) contribution exceeds $10,000 for a single pay period, well above the plausible per-period maximum.',\n    riskStatement: 'Excessive 401(k) contributions violate IRS limits and create compliance and correction obligations.',\n    commonCauses: [\n      'Percentage entered instead of dollar amount',\n      'Annual limit amount entered for a single period',\n      'Catch-up contribution calculated incorrectly',\n      'System error in contribution calculation',\n    ],\n    reviewSteps: [\n      'Verify the 401(k) contribution amount is correct',\n      'Check if the percentage vs. dollar amount is properly configured',\n      'Compare against the IRS annual limit ($23,500 for 2025)',\n      'Correct the contribution amount',\n    ],\n  },\n];\n\nconst crossCategoryRules = [\n  {\n    id: 'GROSS_MINUS_TAXES_DEDUCTIONS_NE_NET',\n    name: 'Gross - Taxes - Deductions != Net',\n    category: 'Cross-Category',\n    severity: 'blocker',\n    confidence: 1.0,\n    confidenceLevel: 'VERY_HIGH',\n    condition: (ctx) => {\n      const gross = ctx.current.gross_pay;\n      const net = ctx.current.net_pay;\n      const ded = ctx.current.total_deductions ?? 0;\n      const fedTax = ctx.current.federal_income_tax ?? 0;\n      const ssTax = ctx.current.social_security_tax ?? 0;\n      const medTax = ctx.current.medicare_tax ?? 0;\n      const stateTax = ctx.current.state_income_tax ?? 0;\n      const localTax = ctx.current.local_tax ?? 0;\n\n      if (gross == null || net == null) return false;\n\n      const totalTaxes = fedTax + ssTax + medTax + stateTax + localTax;\n      const expected = gross - totalTaxes - ded;\n      return Math.abs(expected - net) > 2;\n    },\n    explanation: 'Gross - Taxes - Deductions != Net Pay',\n    userAction: 'Reconcile pay components immediately.',\n    columnsUsed: ['GrossPay', 'NetPay', 'TotalDeductions', 'FederalIncomeTaxWithheld', 'SocialSecurityWithheld', 'MedicareWithheld', 'StateIncomeTaxWithheld', 'LocalTaxWithheld'],\n    minTier: 'starter',\n    flagReason: 'The fundamental payroll equation (Gross - Taxes - Deductions = Net) does not balance.',\n    riskStatement: 'A broken pay equation means at least one component is incorrect, affecting employee pay, tax filings, and financial reporting.',\n    commonCauses: [\n      'Tax or deduction component missing from the file',\n      'Imputed income not included in gross',\n      'Employer-paid benefits included in deductions but not gross',\n      'Rounding accumulated across many components',\n    ],\n    reviewSteps: [\n      'Calculate: Gross - All Taxes - All Deductions',\n      'Compare the result to Net Pay',\n      'Identify the missing or extra amount',\n      'Verify all tax and deduction fields are populated',\n      'Correct the values and re-upload',\n    ],\n  },\n  {\n    id: 'MISSING_BASELINE_ROW',\n    name: 'New employee (no baseline)',\n    category: 'Cross-Category',\n    severity: 'review',\n    confidence: 0.9,\n    confidenceLevel: 'HIGH',\n    condition: (ctx) => {\n      if (!ctx.allBaselineEmployees) return false;\n      const empId = ctx.current.employee_id;\n      if (!empId) return false;\n      const inBaseline = ctx.allBaselineEmployees.some(\n        (e) => e.employee_id === empId\n      );\n      return !inBaseline;\n    },\n    explanation: 'Employee not found in baseline - new hire or data gap',\n    userAction: 'Confirm new employee addition.',\n    columnsUsed: ['EmployeeID'],\n    minTier: 'starter',\n    flagReason: 'This employee exists in the current run but not in the baseline (previous) run.',\n    riskStatement: 'New employees should be verified to ensure proper onboarding, tax setup, and benefit enrollment.',\n    commonCauses: [\n      'New hire started this pay period',\n      'Employee transferred from another entity',\n      'Employee was accidentally excluded from the prior file',\n      'Rehire after a gap in employment',\n    ],\n    reviewSteps: [\n      'Confirm this is a valid new hire or transfer',\n      'Verify tax setup (W-4, state withholding)',\n      'Check benefit enrollment is complete',\n      'If not a new hire, investigate why they were missing from baseline',\n    ],\n  },\n  {\n    id: 'EMPLOYEE_MISSING_IN_CURRENT',\n    name: 'Employee missing in current',\n    category: 'Cross-Category',\n    severity: 'info',\n    confidence: 0.85,\n    confidenceLevel: 'MODERATE',\n    condition: (ctx) => {\n      if (!ctx.allCurrentEmployees) return false;\n      const empId = ctx.current.employee_id;\n      if (!empId) return false;\n      const inCurrent = ctx.allCurrentEmployees.some(\n        (e) => e.employee_id === empId\n      );\n      return !inCurrent;\n    },\n    explanation: 'Employee in baseline but missing from current payroll',\n    userAction: 'FYI - verify if terminated or on leave.',\n    columnsUsed: ['EmployeeID'],\n    minTier: 'starter',\n    flagReason: 'An employee present in the previous run is not in the current run.',\n    riskStatement: 'Missing employees may have been terminated, placed on leave, or accidentally excluded.',\n    commonCauses: [\n      'Employee terminated between pay periods',\n      'Employee on unpaid leave',\n      'Employee transferred to another entity',\n      'Accidentally excluded from the export file',\n    ],\n    reviewSteps: [\n      'Verify the employee status in your HR system',\n      'If terminated, confirm final pay was processed',\n      'If on leave, ensure proper leave tracking',\n      'If excluded accidentally, add them back and re-upload',\n    ],\n  },\n];\n\nconst ALL_RULES = [\n  ...employeeIdentityRules,\n  ...hoursComponentsRules,\n  ...earningsComponentsRules,\n  ...fundamentalPayRules,\n  ...taxesComponentsRules,\n  ...deductionsComponentsRules,\n  ...crossCategoryRules,\n];\n\n// ===== Rule Engine =====\n\nconst TIER_RANK = { starter: 0, pro: 1 };\n\nfunction isRuleAvailable(rule, orgTier) {\n  const ruleRank = TIER_RANK[rule.minTier] || 0;\n  const tierRank = TIER_RANK[orgTier] || 0;\n  return tierRank >= ruleRank;\n}\n\nfunction applyRules(ctx, orgTier) {\n  const judgements = [];\n  for (const rule of ALL_RULES) {\n    if (!isRuleAvailable(rule, orgTier)) continue;\n    try {\n      if (rule.condition(ctx)) {\n        judgements.push({\n          rule_id: rule.id,\n          rule_name: rule.name,\n          category: rule.category,\n          severity: rule.severity,\n          is_material: rule.severity === 'blocker' || rule.severity === 'review',\n          is_blocker: rule.severity === 'blocker',\n          confidence_score: rule.confidence,\n          reasoning: rule.explanation,\n          user_action: rule.userAction,\n          columns_used: rule.columnsUsed,\n        });\n      }\n    } catch (e) {\n      // Rule evaluation failed, skip silently\n    }\n  }\n  return judgements;\n}\n\nfunction applyDeltaRules(current, baseline, metric, currentValue, baselineValue, allCurrentEmployees, allBaselineEmployees, orgTier) {\n  const deltaAbsolute = baselineValue != null ? currentValue - baselineValue : null;\n  const deltaPercentage = baselineValue != null && baselineValue !== 0\n    ? ((currentValue - baselineValue) / Math.abs(baselineValue)) * 100\n    : null;\n  const ctx = {\n    current,\n    baseline: baseline || undefined,\n    metric,\n    currentValue,\n    baselineValue: baselineValue != null ? baselineValue : undefined,\n    deltaAbsolute: deltaAbsolute != null ? deltaAbsolute : undefined,\n    deltaPercentage: deltaPercentage != null ? deltaPercentage : undefined,\n    allCurrentEmployees,\n    allBaselineEmployees,\n  };\n  return applyRules(ctx, orgTier);\n}\n\nfunction applyEmployeeRules(current, baseline, allCurrentEmployees, allBaselineEmployees, orgTier) {\n  const ctx = {\n    current,\n    baseline: baseline || undefined,\n    metric: '__employee_level__',\n    allCurrentEmployees,\n    allBaselineEmployees,\n  };\n  return applyRules(ctx, orgTier);\n}\n\n// ===== Apply Rules to Deltas =====\n\nconst currentMap = new Map(currentEmployees.map(e => [e.employee_id, e]));\nconst baselineMap = new Map(baselineEmployees.map(e => [e.employee_id, e]));\n\nconst allJudgementRows = [];\n\n// Group deltas by employee\nconst deltasByEmployee = new Map();\nfor (const delta of insertedDeltas) {\n  const empDeltas = deltasByEmployee.get(delta.employee_id) || [];\n  empDeltas.push(delta);\n  deltasByEmployee.set(delta.employee_id, empDeltas);\n}\n\nfor (const [employeeId, empDeltas] of deltasByEmployee) {\n  const currentEmp = currentMap.get(employeeId);\n  const baselineEmp = baselineMap.get(employeeId) || null;\n  const seenRuleIds = new Set();\n\n  const repDelta = empDeltas.find(d => d.metric === 'net_pay') || empDeltas[0];\n\n  // Employee-level rules\n  const empRecord = currentEmp || baselineEmp;\n  if (empRecord) {\n    const empJudgements = applyEmployeeRules(\n      empRecord,\n      currentEmp ? baselineEmp : null,\n      currentEmployees,\n      baselineEmployees,\n      orgTier,\n    );\n    for (const j of empJudgements) {\n      if (!seenRuleIds.has(j.rule_id)) {\n        seenRuleIds.add(j.rule_id);\n        allJudgementRows.push({\n          delta_id: repDelta.delta_id,\n          is_material: j.is_material,\n          is_blocker: j.is_blocker,\n          confidence_score: j.confidence_score,\n          reasoning: j.reasoning,\n          rule_id: j.rule_id,\n        });\n      }\n    }\n  }\n\n  // Delta-specific rules\n  for (const delta of empDeltas) {\n    if (delta.change_type === 'new_employee' || delta.change_type === 'removed_employee') continue;\n\n    if (currentEmp) {\n      const deltaJudgements = applyDeltaRules(\n        currentEmp,\n        baselineEmp,\n        delta.metric,\n        delta.current_value ?? 0,\n        delta.baseline_value,\n        currentEmployees,\n        baselineEmployees,\n        orgTier,\n      );\n      for (const j of deltaJudgements) {\n        if (!seenRuleIds.has(j.rule_id)) {\n          seenRuleIds.add(j.rule_id);\n          allJudgementRows.push({\n            delta_id: delta.delta_id,\n            is_material: j.is_material,\n            is_blocker: j.is_blocker,\n            confidence_score: j.confidence_score,\n            reasoning: j.reasoning,\n            rule_id: j.rule_id,\n          });\n        }\n      }\n    }\n  }\n}\n\nconst materialCount = allJudgementRows.filter(j => j.is_material).length;\nconst blockerCount = allJudgementRows.filter(j => j.is_blocker).length;\n\n// Insert judgements in batches\nconst BATCH_SIZE = 200;\nif (allJudgementRows.length > 0) {\n  for (let i = 0; i < allJudgementRows.length; i += BATCH_SIZE) {\n    const batch = allJudgementRows.slice(i, i + BATCH_SIZE);\n    const res = await fetch(SUPABASE_URL + '/rest/v1/material_judgement', {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n    if (!res.ok) throw new Error('Failed to insert judgements: ' + await res.text());\n  }\n}\n\nreturn [{\n  json: {\n    reviewSessionId,\n    judgementCount: allJudgementRows.length,\n    materialCount,\n    blockerCount,\n    deltaCount: insertedDeltas.length,\n  }\n}];",
        "mode": "runOnceForAllItems"
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000004",
      "name": "Apply Rules",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ==========================================================================\n// Code Node 4: Update Session Status\n// Auto-generated by scripts/generate-n8n-workflow.js\n// ==========================================================================\n\n// fetch polyfill for n8n Code node sandbox\nconst https = require('https');\nconst http = require('http');\n\n// Parse URL manually since URL class is not available in sandbox\nfunction parseUrl(urlStr) {\n  const match = urlStr.match(/^(https?):\\/\\/([^:/]+)(?::(\\d+))?(\\/.*)?$/);\n  if (!match) throw new Error('Invalid URL: ' + urlStr);\n  return {\n    protocol: match[1],\n    hostname: match[2],\n    port: match[3] ? parseInt(match[3]) : (match[1] === 'https' ? 443 : 80),\n    path: match[4] || '/'\n  };\n}\n\nfunction fetch(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const u = parseUrl(url);\n    const mod = u.protocol === 'https' ? https : http;\n    const req = mod.request({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      method: options.method || 'GET',\n      headers: options.headers || {},\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        resolve({\n          ok: res.statusCode >= 200 && res.statusCode < 300,\n          status: res.statusCode,\n          statusText: res.statusMessage || '',\n          json: () => JSON.parse(data),\n          text: () => data,\n        });\n      });\n    });\n    req.on('error', reject);\n    if (options.body) req.write(options.body);\n    req.end();\n  });\n}\n\nconst SUPABASE_URL = $env.SUPABASE_URL;\nconst SUPABASE_KEY = $env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst input = $input.first().json;\nconst { reviewSessionId, judgementCount, materialCount, blockerCount, deltaCount } = input;\n\nconst headers = {\n  'apikey': SUPABASE_KEY,\n  'Authorization': 'Bearer ' + SUPABASE_KEY,\n  'Content-Type': 'application/json',\n  'Prefer': 'return=representation',\n};\n\n// Update review session status to completed\nconst res = await fetch(\n  SUPABASE_URL + '/rest/v1/review_session?review_session_id=eq.' + reviewSessionId,\n  {\n    method: 'PATCH',\n    headers,\n    body: JSON.stringify({\n      status: 'completed',\n    }),\n  }\n);\n\nif (!res.ok) throw new Error('Failed to update review session: ' + await res.text());\n\nreturn [{\n  json: {\n    success: true,\n    reviewSessionId,\n    deltaCount,\n    judgementCount,\n    materialCount,\n    blockerCount,\n  }\n}];",
        "mode": "runOnceForAllItems"
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000005",
      "name": "Update Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($input.first().json) }}"
      },
      "id": "a1b2c3d4-0001-4000-8000-000000000006",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1500,
        0
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Fetch Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Data": {
      "main": [
        [
          {
            "node": "Calculate Deltas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Deltas": {
      "main": [
        [
          {
            "node": "Apply Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Rules": {
      "main": [
        [
          {
            "node": "Update Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Status": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "tags": []
}